// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";

/// @dev Interface for the Groth16 verifier generated by snarkjs from the
///      income_proof circuit.  The generated contract exposes:
///        function verifyProof(
///            uint[2] calldata _pA,
///            uint[2][2] calldata _pB,
///            uint[2] calldata _pC,
///            uint[3] calldata _pubSignals   // [threshold, commitment, valid]
///        ) public view returns (bool)
interface IGroth16Verifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[3] calldata _pubSignals
    ) external view returns (bool);
}

/// @title CredentialVerifier
/// @notice Verifies ZK proofs of income and stores non-transferable verified
///         credentials on-chain. Lenders, landlords, and protocols can query
///         whether an address has a verified income credential above a given
///         threshold.
contract CredentialVerifier is Ownable {

    // -----------------------------------------------------------------------
    //  Types
    // -----------------------------------------------------------------------

    struct IncomeCredential {
        uint256 threshold;   // The income threshold proven (e.g. 50000 for $50k)
        uint256 timestamp;   // When the credential was verified
        bytes32 commitment;  // The payroll commitment the proof was against
        bool valid;          // Whether this credential is still valid
    }

    // -----------------------------------------------------------------------
    //  Storage
    // -----------------------------------------------------------------------

    /// @notice The Groth16 verifier contract generated from the Circom circuit
    IGroth16Verifier public zkVerifier;

    /// @notice employee address => array of verified credentials
    mapping(address => IncomeCredential[]) private _credentials;

    /// @notice Quick lookup: employee => threshold => true if verified
    mapping(address => mapping(uint256 => bool)) public hasVerifiedIncome;

    /// @notice Credential expiry duration (default 365 days)
    uint256 public credentialValidity = 365 days;

    // -----------------------------------------------------------------------
    //  Events
    // -----------------------------------------------------------------------

    event IncomeVerified(
        address indexed employee,
        uint256 threshold,
        bytes32 commitment,
        uint256 timestamp
    );
    event CredentialRevoked(address indexed employee, uint256 index);
    event VerifierUpdated(address indexed oldVerifier, address indexed newVerifier);

    // -----------------------------------------------------------------------
    //  Errors
    // -----------------------------------------------------------------------

    error InvalidProof();
    error ZeroAddress();
    error ProofOutputInvalid();

    // -----------------------------------------------------------------------
    //  Constructor
    // -----------------------------------------------------------------------

    /// @param _zkVerifier Address of the deployed Groth16 Verifier.sol
    constructor(address _zkVerifier) Ownable(msg.sender) {
        if (_zkVerifier == address(0)) revert ZeroAddress();
        zkVerifier = IGroth16Verifier(_zkVerifier);
    }

    // -----------------------------------------------------------------------
    //  Admin
    // -----------------------------------------------------------------------

    function setVerifier(address _zkVerifier) external onlyOwner {
        if (_zkVerifier == address(0)) revert ZeroAddress();
        address old = address(zkVerifier);
        zkVerifier = IGroth16Verifier(_zkVerifier);
        emit VerifierUpdated(old, _zkVerifier);
    }

    function setCredentialValidity(uint256 _duration) external onlyOwner {
        credentialValidity = _duration;
    }

    // -----------------------------------------------------------------------
    //  Verification
    // -----------------------------------------------------------------------

    /// @notice Verify a ZK proof that the caller's income >= threshold.
    /// @dev    Public signals layout from the circuit:
    ///           [0] = threshold
    ///           [1] = commitment (Poseidon hash)
    ///           [2] = valid (1 if salary >= threshold)
    /// @param _pA  Groth16 proof element A.
    /// @param _pB  Groth16 proof element B.
    /// @param _pC  Groth16 proof element C.
    /// @param _pubSignals  [threshold, commitment, valid].
    /// @return True if proof is valid and credential is stored.
    function verifyIncomeProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[3] calldata _pubSignals
    ) external returns (bool) {
        // Verify the Groth16 proof
        bool proofValid = zkVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        if (!proofValid) revert InvalidProof();

        // The circuit's `valid` output must be 1
        if (_pubSignals[2] != 1) revert ProofOutputInvalid();

        uint256 threshold = _pubSignals[0];
        bytes32 commitment = bytes32(_pubSignals[1]);

        // Store credential (non-transferable, tied to msg.sender)
        _credentials[msg.sender].push(IncomeCredential({
            threshold: threshold,
            timestamp: block.timestamp,
            commitment: commitment,
            valid: true
        }));

        hasVerifiedIncome[msg.sender][threshold] = true;

        emit IncomeVerified(msg.sender, threshold, commitment, block.timestamp);

        return true;
    }

    // -----------------------------------------------------------------------
    //  Queries
    // -----------------------------------------------------------------------

    /// @notice Check if an address has a currently valid income credential
    ///         for at least `threshold`.
    function checkIncomeCredential(
        address employee,
        uint256 threshold
    ) external view returns (bool) {
        IncomeCredential[] storage creds = _credentials[employee];
        for (uint256 i = 0; i < creds.length; i++) {
            if (
                creds[i].valid &&
                creds[i].threshold >= threshold &&
                block.timestamp <= creds[i].timestamp + credentialValidity
            ) {
                return true;
            }
        }
        return false;
    }

    /// @notice Get all credentials for an employee.
    function getCredentials(
        address employee
    ) external view returns (IncomeCredential[] memory) {
        return _credentials[employee];
    }

    /// @notice Get the number of credentials for an employee.
    function getCredentialCount(address employee) external view returns (uint256) {
        return _credentials[employee].length;
    }

    // -----------------------------------------------------------------------
    //  Revocation
    // -----------------------------------------------------------------------

    /// @notice Revoke one of your own credentials.
    function revokeCredential(uint256 index) external {
        IncomeCredential[] storage creds = _credentials[msg.sender];
        require(index < creds.length, "Index out of bounds");
        creds[index].valid = false;
        hasVerifiedIncome[msg.sender][creds[index].threshold] = false;

        emit CredentialRevoked(msg.sender, index);
    }
}
